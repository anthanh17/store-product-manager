// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: products.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProductCategory = `-- name: AddProductCategory :exec
INSERT INTO product_categories (
  product_id,
  category_id
) VALUES (
  $1, $2
)
`

type AddProductCategoryParams struct {
	ProductID  int32 `json:"product_id"`
	CategoryID int32 `json:"category_id"`
}

func (q *Queries) AddProductCategory(ctx context.Context, arg AddProductCategoryParams) error {
	_, err := q.db.Exec(ctx, addProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name,
  description,
  price,
  stock_quantity,
  status,
  image_url
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, name, description, price, stock_quantity, status, image_url, created_at, updated_at
`

type CreateProductParams struct {
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	Price         float64     `json:"price"`
	StockQuantity int32       `json:"stock_quantity"`
	Status        string      `json:"status"`
	ImageUrl      pgtype.Text `json:"image_url"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.StockQuantity,
		arg.Status,
		arg.ImageUrl,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Status,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductCategories = `-- name: DeleteProductCategories :exec
DELETE FROM product_categories
WHERE product_id = $1
`

func (q *Queries) DeleteProductCategories(ctx context.Context, productID int32) error {
	_, err := q.db.Exec(ctx, deleteProductCategories, productID)
	return err
}

const getProduct = `-- name: GetProduct :one
SELECT p.id, p.name, p.description, p.price, p.stock_quantity, p.status, p.image_url, p.created_at, p.updated_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', c.id,
                   'name', c.name
               )
           ) FILTER (WHERE c.id IS NOT NULL), '[]'
       ) as categories
FROM products p
LEFT JOIN product_categories pc ON p.id = pc.product_id
LEFT JOIN categories c ON pc.category_id = c.id
WHERE p.id = $1
GROUP BY p.id
LIMIT 1
`

type GetProductRow struct {
	ID            int32       `json:"id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	Price         float64     `json:"price"`
	StockQuantity int32       `json:"stock_quantity"`
	Status        string      `json:"status"`
	ImageUrl      pgtype.Text `json:"image_url"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	Categories    interface{} `json:"categories"`
}

func (q *Queries) GetProduct(ctx context.Context, id int32) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Status,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
	)
	return i, err
}

const getProductCategories = `-- name: GetProductCategories :many
SELECT c.id, c.name, c.description
FROM categories c
JOIN product_categories pc ON c.id = pc.category_id
WHERE pc.product_id = $1
`

func (q *Queries) GetProductCategories(ctx context.Context, productID int32) ([]Category, error) {
	rows, err := q.db.Query(ctx, getProductCategories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductReviews = `-- name: GetProductReviews :many
SELECT r.id, r.product_id, r.user_id, u.username, r.rating, r.comment, r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.product_id = $1
ORDER BY r.created_at DESC
`

type GetProductReviewsRow struct {
	ID        int32       `json:"id"`
	ProductID int32       `json:"product_id"`
	UserID    int32       `json:"user_id"`
	Username  string      `json:"username"`
	Rating    int32       `json:"rating"`
	Comment   pgtype.Text `json:"comment"`
	CreatedAt time.Time   `json:"created_at"`
}

func (q *Queries) GetProductReviews(ctx context.Context, productID int32) ([]GetProductReviewsRow, error) {
	rows, err := q.db.Query(ctx, getProductReviews, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductReviewsRow{}
	for rows.Next() {
		var i GetProductReviewsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.Username,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllProductCategories = `-- name: RemoveAllProductCategories :exec
DELETE FROM product_categories
WHERE product_id = $1
`

func (q *Queries) RemoveAllProductCategories(ctx context.Context, productID int32) error {
	_, err := q.db.Exec(ctx, removeAllProductCategories, productID)
	return err
}

const removeProductCategory = `-- name: RemoveProductCategory :exec
DELETE FROM product_categories
WHERE product_id = $1 AND category_id = $2
`

type RemoveProductCategoryParams struct {
	ProductID  int32 `json:"product_id"`
	CategoryID int32 `json:"category_id"`
}

func (q *Queries) RemoveProductCategory(ctx context.Context, arg RemoveProductCategoryParams) error {
	_, err := q.db.Exec(ctx, removeProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
  name = $2,
  description = $3,
  price = $4,
  stock_quantity = $5,
  status = $6,
  image_url = $7,
  updated_at = now()
WHERE id = $1
RETURNING id, name, description, price, stock_quantity, status, image_url, created_at, updated_at
`

type UpdateProductParams struct {
	ID            int32       `json:"id"`
	Name          string      `json:"name"`
	Description   pgtype.Text `json:"description"`
	Price         float64     `json:"price"`
	StockQuantity int32       `json:"stock_quantity"`
	Status        string      `json:"status"`
	ImageUrl      pgtype.Text `json:"image_url"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.StockQuantity,
		arg.Status,
		arg.ImageUrl,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Status,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
